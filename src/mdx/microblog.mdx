---
title: "Microblog"
post_date: "2025-01-16"
post_category: "quotes_links"
description: "My microblog"
code_url: "https://github.com/RobinL/robinl.github.io/blob/dev/src/mdx/microblog.mdx"
---

export { MDXLayout as default } from '../components/MDXLayout';
import { SEO } from "../components/SEO"
import Microblog from "../components/Microblog"
import { Link } from "gatsby"

export const Head = ( props ) => <SEO frontmatter={props.pageContext.frontmatter} />;

# Microblog

<Microblog
    title="ClickHouse Obfuscator - Data Anonymization Tool"
    date="2024-01-16"
    tags={["clickhouse", "data", "privacy"]}
>
The [ClickHouse obfuscator](https://clickhouse.com/docs/en/operations/utilities/clickhouse-obfuscator) is a tool for anonymizing production data while preserving its key statistical properties. It maintains:

- Value cardinalities and distributions
- Data compression ratios
- String lengths and UTF-8 validity
- Time series continuity

See also [here](https://github.com/ClickHouse/ClickHouse/tree/master/programs/obfuscator)
</Microblog>


<Microblog
    title="National Data Library thoughts"
    date="2024-01-16"
    tags={["data", "governance", "AI"]}
>
Three key priorities for building a National Data Library:

1. Data sharing and governance must come first - before any technical solutions. Success depends on data owners being convinced the NDL will make their lives easier, not harder.

2. Access permissions and management systems need to be rock-solid before building analytical capabilities. Get the foundations right.

3. Design for an AI-first future - by the time the NDL is delivered, most analysis will likely be AI-assisted. The architecture needs to anticipate this.
</Microblog>

<Microblog
    title="Understanding DuckDB Connection Types in Python"
    date="2024-01-16"
    tags={["python", "duckdb", "database"]}
>
DuckDB offers special connection types in Python:

- `:memory:name` - Creates/connects to a named in-memory database that can be shared across connections
- `:default:` - Uses the default connection stored in the DuckDB module

Example:
```python
import duckdb

# Create table in default connection
duckdb.execute("CREATE TABLE tbl AS SELECT 42 as value")

# Access same table through explicit default connection
con = duckdb.connect(":default:")
con.sql("SELECT * FROM tbl")  # Works!

# Shared named memory connection
con3 = duckdb.connect(":memory:shared_db")
con4 = duckdb.connect(":memory:shared_db")  # Same database as con3
```

See docs [here](https://duckdb.org/docs/api/python/dbapi.html)
</Microblog>

<Microblog
    title="Configuring Python Path Visibility in VS Code interactive window (Jupyter)"
    date="2024-01-16"
    tags={["vscode", "jupyter", "tips"]}
>
When working with Jupyter notebooks in VS Code, add these settings to your `.vscode/settings.json`:
```json
{
    "jupyter.notebookFileRoot": "${workspaceFolder}",
    "python.analysis.extraPaths": [
        "${workspaceFolder}"
    ]
}
```

Now, the interactive window will run any script as if it's running from the root directory even if it's nested
</Microblog>


