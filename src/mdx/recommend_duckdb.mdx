---
title: "Why DuckDB is my first choice for data processing"
description: ""
post_date: "2025-03-16"
post_category: "data"
code_url: "https://github.com/RobinL/robinl.github.io/blob/dev/src/mdx/recommend_duckdb.mdx"
---

export { MDXLayout as default } from '../components/MDXLayout';
import { SEO } from "../components/SEO"
export const Head = ( props ) => <SEO frontmatter={props.pageContext.frontmatter} />;
import { Link } from "gatsby";

# Why DuckDB is my first choice for data processing

Over the past few years, I've found myself using DuckDB more and more for data processing, to the point where I now use it almost exclusively, usually from within Python.

With DuckDB, I believe we're moving towards a simpler world where most tabular data can be processed on a single large machine. To my great pleasure [^1], the era of clusters is coming to an end for all but the largest datasets. [^2]

[^1]: As a long-time Spark user, I am glad to be rid of needing to know lots of intricate configuration options for Spark tuning
[^2]: There is actually now a distributed version of DuckDB, see [here](https://mehdio.substack.com/p/duckdb-goes-distributed-deepseeks)

This post sets out some of my favourite features of DuckDB that set it apart from other SQL-based tools.  An  <Link to ="/recommend_sql/">earlier post</Link> explains why I favour SQL.   In a nutshell, it's simple to manage, ergonomic, fast, and more fully featured than other SQL-based tools.


# What is DuckDB?

DuckDB is an open source in-process SQL engine that is optimised for analytics queries.

- 'In-process' means its similar to SQLite in that it runns within your application and you don't need to start a separate service to run it. like you would with (say) Postgres.
- 'Optimised for analytics queries' means that it's designed for operations like large joins and aggregations involving large numbers of rows, as opposed to atomic transactions.

The performance difference of of analytics-optimised engines (sometimes called OLAP) vs. transactions-optimised engines (sometimes called OLTP) should not be underestimated. A query running in (say) SQlite or Postgres can be 100 or even 1,000 times slower than exactly same query running in DuckDB.

A core use-case of DuckDB is that you have one or more large datasets on disk in one or more formats like `csv`, `parquet` or `json`,  and want to batch-process these, performing cleaning, joins, aggregation, derivation of new columns or some mix of these.

But DuckDB is also very effective for many other simpler tasks like simply viewing a csv file on the command line.

# What are my favourite features

## Speed

DuckDB consistently benchmarks as one of the fastest data processing engines.  The benchmarks I've seen[^3] show there's not much in it between the leading open source engines - which at the moment seem to be [polars](https://pola.rs/), [duckdb](https://duckdb.org/) and [Datafusion](https://datafusion.apache.org/),  [Spark](https://spark.apache.org/) and [Dask](https://www.dask.org/).  Spark and Dask can be competitive on large data, but slower on small data.

[^3]: For instance see [here](https://docs.coiled.io/blog/tpch.html), [here](https://duckdblabs.github.io/db-benchmark/) and [here](https://milescole.dev/data-engineering/2024/12/12/Should-You-Ditch-Spark-DuckDB-Polars.html)/[discusson](https://news.ycombinator.com/item?id=42419224).

## Simple to install, no dependencies

DuckDB itself is a single precompiled binary.  In Python, it can be installed `pip install` with no dependencies.  This makes it a joy to install compared to other more heavyweight options like Spark.

Combined with its speed and almost-zero startup time, this is particularly important because it enables much easier CI and testing of data engineering pipelines.  Historically this has been fiddly and running a large suite of tests in e.g. Apache Spark has been time consuming and frustrating.

















Finally, I love that DuckDB is has the duckdb foundation, so the business model seems good.