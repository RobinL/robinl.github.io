"use strict";(self.webpackChunkrobinlinacre=self.webpackChunkrobinlinacre||[]).push([[2376,1223,3877],{6e3:function(e,t,n){n.r(t),n.d(t,{Head:function(){return m}});var a=n(1151),l=n(7294),r=n(7848),s=n(7825),i=n(6760),o=n(4160),c=n(40),d=n(9373);const m=e=>l.createElement(s.H,{frontmatter:e.pageContext.frontmatter});function u(e){const t=Object.assign({h1:"h1",h2:"h2",p:"p",sup:"sup",a:"a",mark:"mark",ul:"ul",li:"li",code:"code",h3:"h3",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",ol:"ol",em:"em",strong:"strong",section:"section"},(0,a.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(t.h1,null,"Building Accurate Address Matching Systems"),"\n",l.createElement(i.Z,null,"A bag of tricks to improve the accuracy of geocoding"),"\n",l.createElement(t.h2,null,"The challenge"),"\n",l.createElement(t.p,null,"Address matching is a notoriously difficult problem due to unpredictable structure of addresses",l.createElement(t.sup,null,l.createElement(t.a,{href:"#user-content-fn-8",id:"user-content-fnref-8","data-footnote-ref":!0,"aria-describedby":"footnote-label"},"1"))," and the many different ways an address can be written."),"\n",l.createElement(t.p,null,"Substantial variation can exist between two matching addresses - for instance:"),"\n",l.createElement(c.default,{addressA:l.createElement(l.Fragment,null,l.createElement(t.mark,null,"Flat")," 165 ",l.createElement(t.mark,null,"Block 3")," Philpot Square, ",l.createElement(t.mark,null,"Hammersmith And Fulham")),addressB:l.createElement(l.Fragment,null,"165, Philpot Square, ",l.createElement(t.mark,null,"London")),isMatch:!0}),"\n",l.createElement(t.p,null,"whereas the following example has far less variation, yet does not match:"),"\n",l.createElement(c.default,{addressA:l.createElement(l.Fragment,null,"Flat A 2",l.createElement(t.mark,null,"4")," Jubilee Street, London, LO1 23D"),addressB:l.createElement(l.Fragment,null,"Flat A 2",l.createElement(t.mark,null,"5")," Jubilee Street, London, LO1 23D"),isMatch:!1}),"\n",l.createElement(t.p,null,"The challenge is therefore to develop an algorithm that can somehow 'see' that the first pair of addresses are more similar than the second pair."),"\n",l.createElement(t.p,null,"Unfortunately one of the most effective general approaches to record linkage – known as the ",l.createElement(o.rU,{to:"/intro_to_probabilistic_linkage/"},"Fellegi-Sunter model")," and implemented in ",l.createElement(t.a,{href:"http://github.com/moj-analytical-services/splink"},"Splink")," – is not well suited to address matching because:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"there is a strong correlation between different parts of an address, violating the model's statistical assumptions"),"\n",l.createElement(t.li,null,"the model assumes input data is split across multiple columns (e.g. first name, surname, DoB etc.), but address data is often received as a single string, and reliably parsing this into a set of standardised columns is difficult"),"\n"),"\n",l.createElement(t.p,null,"In this post, I share some tricks and feature engineering techniques we can use to exploit the information in addresses as much as possible, to maximise geocoding accuracy.",l.createElement(t.sup,null,l.createElement(t.a,{href:"#user-content-fn-3",id:"user-content-fnref-3","data-footnote-ref":!0,"aria-describedby":"footnote-label"},"2"))),"\n",l.createElement(t.p,null,"Concrete implementations of some of these tricks can be found in two open source address matching libraries:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.a,{href:"https://github.com/RobinL/uk_address_matcher"},l.createElement(t.code,null,"uk_address_matcher")),l.createElement("span",{style:{marginLeft:"0.25em",verticalAlign:"0.0em"},"aria-label":"external link",title:"External link"},l.createElement("svg",{width:"16",height:"16",viewBox:"0 0 24 24","aria-hidden":"true"},l.createElement("path",{d:"M14 3h7v7h-2V6.414l-9.293 9.293-1.414-1.414L17.586 5H14V3z",fill:"#2563eb"}),l.createElement("path",{d:"M5 5h5v2H7v10h10v-3h2v5H5V5z",fill:"#2563eb"})))," a ",l.createElement(t.a,{href:"https://github.com/moj-analytical-services/splink"},"Splink")," based address matching library focussed on UK addresses"),"\n",l.createElement(t.li,null,l.createElement(t.a,{href:"https://github.com/ajl2718/whereabouts"},l.createElement(t.code,null,"whereabouts")),l.createElement("span",{style:{marginLeft:"0.25em",verticalAlign:"0.0em"},"aria-label":"external link",title:"External link"},l.createElement("svg",{width:"16",height:"16",viewBox:"0 0 24 24","aria-hidden":"true"},l.createElement("path",{d:"M14 3h7v7h-2V6.414l-9.293 9.293-1.414-1.414L17.586 5H14V3z",fill:"#2563eb"}),l.createElement("path",{d:"M5 5h5v2H7v10h10v-3h2v5H5V5z",fill:"#2563eb"}))),", a DuckDB-powered address matching library, using ",l.createElement(t.a,{href:"https://arxiv.org/pdf/1712.09691?"},"signature based")," geocoding methods. Initially developed for Australian addresses, it also supports the creation of geocoding databases for other countries"),"\n"),"\n",l.createElement(t.h2,null,"Structuring the problem"),"\n",l.createElement(t.p,null,"I will assume that we have:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"A list of messy addresses (e.g. addresses that have been entered by hand by users)"),"\n",l.createElement(t.li,null,"A canonical address file (e.g. in the UK, an Ordnance Survey product such as ",l.createElement(t.a,{href:"https://docs.os.uk/osngd/data-structure/address/gb-address"},"Built Address"),")"),"\n"),"\n",l.createElement(t.p,null,"To be as general as possible, we'll assume the address in these files is just a single string."),"\n",l.createElement(t.p,null,"The address matching problem can be structured into two main stages:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.a,{href:"https://moj-analytical-services.github.io/splink/topic_guides/blocking/blocking_rules.html?h=blocking#blocking"},"Blocking")," (finding a small number of plausible candidates from the canonical address file)"),"\n",l.createElement(t.li,null,"Scoring (to rank the candidates and thereby identify the best match)."),"\n"),"\n",l.createElement(t.p,null,"These steps are independent, so we can mix and match different blocking and scoring techniques."),"\n",l.createElement(t.p,null,"However, prior to either of these steps, we need to decide how best to represent the address data."),"\n",l.createElement(t.h2,null,"How to represent the address data - a data-driven approach"),"\n",l.createElement(t.p,null,"A tempting first step is to attempt to parse the messy addresses semantically - e.g. splitting out flat number, house number, street name and so on.",l.createElement(t.sup,null,l.createElement(t.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label"},"3"))),"\n",l.createElement(t.p,null,"This is appealing because it appears to enable powerful scoring rules, such as 'if the building number is different, the addresses do not match'."),"\n",l.createElement(t.p,null,"In practice, this approach suffers from a paradox: the hardest addresses to match often contain ambiguities which make them the hardest to parse, and the problem of parsing the address correctly collapses into needing to  find the true address.",l.createElement(t.sup,null,l.createElement(t.a,{href:"#user-content-fn-9",id:"user-content-fnref-9","data-footnote-ref":!0,"aria-describedby":"footnote-label"},"4"))),"\n",l.createElement(t.p,null,"As a result, a data-driven approach is more powerful. We can treat the address as a single string from which we can extract certain features such as 'the first number' or 'most unusual bigram' without attaching too much semantic meaning.  This enables us to draw on aggregate characteristics of the data itself to detect the most important features of the address."),"\n",l.createElement(t.p,null,"It gives us greater flexibility in feature engineering, because we can find features that have no particular structural or semantic meaning but are nonetheless useful for matching."),"\n",l.createElement(t.p,null,"It also prevents us being too rigid later in our blocking and scoring approaches - for example, it avoids the trap of logic like 'if the building number is different then it's not a match' - which contains an implicit assumption of complete information that's correctly parsed."),"\n",l.createElement(t.h2,null,"Blocking stage"),"\n",l.createElement(t.p,null,"The purpose of blocking is to recover a list of plausible candidate addresses.  The aim of the blocking stage is to have high recall (i.e. not to miss the true match)",l.createElement(t.sup,null,l.createElement(t.a,{href:"#user-content-fn-10",id:"user-content-fnref-10","data-footnote-ref":!0,"aria-describedby":"footnote-label"},"5")),".  Precision is less important, because we will be scoring the candidates to find the true match at the next stage."),"\n",l.createElement(t.p,null,"For example, a simple blocking strategy could be to find all addresses in the postcode of the query address",l.createElement(t.sup,null,l.createElement(t.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label"},"6")),".  This is a good start, but in practice suffers two flaws:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"The list of candidates can be excessively long, resulting in slower scoring performance"),"\n",l.createElement(t.li,null,"The query address may not have a postcode, or the postcode may be incorrect"),"\n"),"\n",l.createElement(t.p,null,"As a result we need to supplement a postcode-based blocking strategy with some additional techniques.  The idea is that any of these techniques in isolation may miss the true match, but the  combined results should almost always contain it."),"\n",l.createElement(t.h3,null,"1. Surmounting problems of common tokens: n-grams combined with term frequencies"),"\n",l.createElement(t.p,null,"We can pre-process addresses to extract n-grams and their associated term frequencies (frequency of occurrence across the corpus of all addresses).   This allows us to identify which tokens are uncommon enough to be useful for blocking (i.e. will restrict the number of candidates to a manageable number)."),"\n",l.createElement(t.p,null,"Many strategies are possible here, but a simple approach could be to identify the least common bigram or trigram in each address, and to block on",l.createElement(t.sup,null,l.createElement(t.a,{href:"#user-content-fn-4",id:"user-content-fnref-4","data-footnote-ref":!0,"aria-describedby":"footnote-label"},"7"))," that.  For performance reasons, we'd want to filter out any excessively common ones."),"\n",l.createElement(t.p,null,"For example each individual token in ",l.createElement(t.code,null,"Flat A 24 Jubilee Street London")," is very common, but the tri-gram ",l.createElement(t.code,null,"A 24 Jubilee")," will appear in at most a handful of addresses in the country."),"\n",l.createElement(t.h3,null,"2. Word order: Single words sorted by term frequency"),"\n",l.createElement(t.p,null,"A variation on the n-gram approach is to extract the most unusual single tokens (words) in the address, and block on (say) the two least common tokens in the address."),"\n",l.createElement(t.p,null,"This is useful to avoid the problem of missing or misordered tokens.  For example, in the Philpot Square example, ",l.createElement(t.code,null,"Philpot")," and ",l.createElement(t.code,null,"165")," are unusual tokens and there may only be a single address in the country with both tokens, but they don't predictably appear next to each other."),"\n",l.createElement(t.h3,null,"3.  Discriminating tokens amongst neighbouring addresses"),"\n",l.createElement(t.p,null,"By working back to front and eliminating common tokens, we can identify the following discriminating tokens (highlighted):"),"\n",l.createElement("pre",{style:{display:"inline-block",width:"max-content",textAlign:"right",background:"none",border:"none",padding:0}},l.createElement("pre",null,l.createElement("code",null,l.createElement("mark",null,"1")," Rainbow Lane Taunton TA1 1AB")),l.createElement("pre",null,l.createElement("code",null,l.createElement("mark",null,"2")," Rainbow Lane Taunton TA1 1AB")),l.createElement("pre",null,l.createElement("code",null,l.createElement("mark",null,"Highfield")," Rainbow Lane Taunton TA1 1AB")),l.createElement("pre",null,l.createElement("code",null,l.createElement("mark",null,"Old Station House")," Rainbow Lane Taunton TA1 1AB")),l.createElement("pre",null,l.createElement("code",null,l.createElement("mark",null,"5")," Rainbow Lane Taunton TA1 1AB"))),"\n",l.createElement(t.p,null,"These highlighted n-grams can be used for blocking and can be especially used for non-numeric house names, combined with (say) the first half of the postcode."),"\n",l.createElement(t.h3,null,"4. Signature based blocking"),"\n",l.createElement(t.p,null,"Signature based candidate search, described in ",l.createElement(t.a,{href:"https://arxiv.org/abs/1712.09691"},"this paper")," and implemented in ",l.createElement(t.a,{href:"https://github.com/ajl2718/whereabouts"},l.createElement(t.code,null,"whereabouts")),l.createElement("span",{style:{marginLeft:"0.25em",verticalAlign:"0.0em"},"aria-label":"external link",title:"External link"},l.createElement("svg",{width:"16",height:"16",viewBox:"0 0 24 24","aria-hidden":"true"},l.createElement("path",{d:"M14 3h7v7h-2V6.414l-9.293 9.293-1.414-1.414L17.586 5H14V3z",fill:"#2563eb"}),l.createElement("path",{d:"M5 5h5v2H7v10h10v-3h2v5H5V5z",fill:"#2563eb"})))," is effectively a generalisation of these techniques."),"\n",l.createElement(t.p,null,"The idea is that there is significant redundancy in most addresses, we can devise 'signatures' which are subsets (often n-grams) of the full address which narrow down possible candidates to only a handful of candidates.  Developing signatures is not completely automated and requires domain-specific knowledge.   In this view, the techniques above are examples of types of signatures that may be useful in the context of addresses."),"\n",l.createElement(t.h3,null,"5. Deriving multiple variations of the canonical address"),"\n",l.createElement(t.p,null,"In many cases, the list of canonical addresses will be split robustly and semantically across multiple columns (e.g. the Built Address spec ",l.createElement(t.a,{href:"https://docs.os.uk/osngd/data-structure/address/gb-address/built-address"},"here"),")."),"\n",l.createElement(t.p,null,"If so, we can derive multiple representations of the canonical address by combining these columns in different ways.  This gives a greater chance for blocking to recover the true match, and also means scoring will be more reliable because it increases the similarity between the messy address and the closest representation of the canonical address."),"\n",l.createElement(t.p,null,"For example, the standard representation may not contain 'floor descriptors' like ",l.createElement(t.code,null,"top floor"),", but if this is sometimes observed in the messy addresses, we could add this as a variation onto the canonical address.  Or we may want to ensure that we have both the address with business name and without."),"\n",l.createElement(t.p,null,"This adds accuracy without significantly increasing complexity:  we can treat the variations as additional candidates, score as normal, but then the final score for each candidate becomes the highest score across all variations of the canonical address."),"\n",l.createElement(t.p,null,"This technique also increases the chance of finding an exact match, so the run time performance tradeoff is not unambiguously negative."),"\n",l.createElement(t.h2,null,"Scoring stage"),"\n",l.createElement(t.p,null,"The purpose of the scoring stage is to identify the highest scoring candidate found in the blocking stage, to try to identify the correct match."),"\n",l.createElement(t.p,null,"There are many different scoring approaches, and a weighted combination",l.createElement(t.sup,null,l.createElement(t.a,{href:"#user-content-fn-6",id:"user-content-fnref-6","data-footnote-ref":!0,"aria-describedby":"footnote-label"},"8"))," of approaches will often yield the best results",l.createElement(t.sup,null,l.createElement(t.a,{href:"#user-content-fn-7",id:"user-content-fnref-7","data-footnote-ref":!0,"aria-describedby":"footnote-label"},"9")),"."),"\n",l.createElement(t.h3,null,"1. Token frequencies within the corpus of all addresses"),"\n",l.createElement(t.p,null,"A simple 'first cut' of a scoring approach can be simply to look at the number of common tokens between the messy address and candidate address, weighted by token frequency in the corpus of all addresses."),"\n",l.createElement("details",{style:{border:"1px solid #e5e7eb",borderRadius:"6px",padding:"0.5em",margin:"1em 0"}},l.createElement("summary",{style:{fontWeight:"normal",textAlign:"left",margin:"0em"}}," Example - click to expand"),l.createElement(d.default,{messyAddress:l.createElement(l.Fragment,null,l.createElement(t.mark,null,"24")," ",l.createElement(t.mark,null,"Jubilee")," St, ",l.createElement(t.mark,null,"London")),candidates:[{address:l.createElement(l.Fragment,null,l.createElement(t.mark,null,"24")," ",l.createElement(t.mark,null,"Jubilee")," Street, ",l.createElement(t.mark,null,"London")," LO1 23D")}]}),l.createElement(t.table,null,l.createElement(t.thead,null,l.createElement(t.tr,null,l.createElement(t.th,null,"Overlapping token"),l.createElement(t.th,null,"Share of all addresses containing token"))),l.createElement(t.tbody,null,l.createElement(t.tr,null,l.createElement(t.td,null,l.createElement("mark",null,"24")),l.createElement(t.td,null,"0.15%")),l.createElement(t.tr,null,l.createElement(t.td,null,l.createElement("mark",null,"Jubilee")),l.createElement(t.td,null,"0.003%")),l.createElement(t.tr,null,l.createElement(t.td,null,l.createElement("mark",null,"London")),l.createElement(t.td,null,"5.0%")))),l.createElement(t.p,null,"final score = 0.0015 × 0.00003 × 0.05 ≈ 2.25 × 10⁻⁹"),l.createElement(t.p,null,"The address with the lowest score is ranked the highest.")),"\n",l.createElement(t.p,null,"This is surprisingly effective, but there are several drawbacks that mean it is possible to improve on this approach:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Token frequency in the corpus of all addresses is not a very good metric of the strength of match within a small group of candidates.  For instance, the token ",l.createElement(t.code,null,"London")," is very common in the overall corpus, but for an address in Manchester, it may be highly discriminative."),"\n",l.createElement(t.li,null,"Similarly, a token may be very uncommon in the overall corpus, but useless to distinguish between candidates.  For example, consider the token ",l.createElement(t.code,null,"Rainbow")," in the above list of addresses."),"\n",l.createElement(t.li,null,"Sometimes the true match may have fewer overlapping tokens than a false match.  For example, in the ",l.createElement(t.code,null,"Philpot Square")," example, a different and incorrect candidate may include the tokens ",l.createElement(t.code,null,"Block 3")),"\n"),"\n",l.createElement(t.h3,null,"2. Token (or n-gram) frequencies within candidates"),"\n",l.createElement(t.p,null,"An improvement on using whole-corpus token frequencies is to instead use the frequencies of tokens within the set of candidates.  This is a better measure of the power of the token to distinguish between the candidates."),"\n",l.createElement(t.p,null,"Similarly, we could use the frequency of n-grams within the set of candidates."),"\n",l.createElement("details",{style:{border:"1px solid #e5e7eb",borderRadius:"6px",padding:"0.5em",margin:"1em 0"}},l.createElement("summary",{style:{fontWeight:"normal",textAlign:"left",margin:"0em"}}," Example - click to expand"),l.createElement(t.p,null,"For example, consider how the token 'front' is the only token that appears just once amongst the candidates, making it uniquely powerful because it is the only token that discriminates fully between the candidates."),l.createElement(d.default,{messyAddress:l.createElement(l.Fragment,null,l.createElement(t.mark,null,"Front")," Ground Floor Flat 57 Fulham Park Gardens"),candidates:[{address:l.createElement(l.Fragment,null,"Flat Ground Floor ",l.createElement(t.mark,null,"Front"),", 57, Fulham Park Gardens"),isMatch:!0},{address:l.createElement(l.Fragment,null,"Flat First Floor, 57, Fulham Park Gardens"),isMatch:!1},{address:l.createElement(l.Fragment,null,"Flat Ground Floor, 66, Fulham Park Gardens"),isMatch:!1},{address:l.createElement(l.Fragment,null,"Flat Ground Floor Rear, 57, Fulham Park Gardens"),isMatch:!1}]})),"\n",l.createElement(t.h3,null,"3. Absence of tokens:  Punishing missing tokens"),"\n",l.createElement(t.p,null,"Where tokens do not overlap, we can apply a penalty to the candidate's score:"),"\n",l.createElement("svg",{width:"240",height:"160",viewBox:"0 0 240 160",xmlns:"http://www.w3.org/2000/svg"},l.createElement("circle",{cx:"90",cy:"90",r:"60",fill:"rgba(255,0,0,0.4)"}),l.createElement("circle",{cx:"150",cy:"90",r:"60",fill:"rgba(0,0,255,0.4)"}),l.createElement("text",{x:"50",y:"20","font-size":"14","text-anchor":"middle"},"Messy tokens"),l.createElement("text",{x:"170",y:"20","font-size":"14","text-anchor":"middle"},"Candidate tokens"),l.createElement("text",{x:"60",y:"95","font-size":"18","text-anchor":"middle"},"M"),l.createElement("text",{x:"170",y:"95","font-size":"18","text-anchor":"middle"},"C"),l.createElement("text",{x:"120",y:"95","font-size":"14","text-anchor":"middle"},"M ∩ C")),"\n",l.createElement(t.p,null,"How do we treat tokens in areas M and C?"),"\n",l.createElement(t.p,null,"This turns out to be trickier than it first appears because we can't treat all absent tokens as equal:"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"There are a variety of optional tokens that tend to occur towards the end of an address whose absence is close to irrelevant.  Examples may include ",l.createElement(t.code,null,"London"),",  the names of counties (e.g. ",l.createElement(t.code,null,"Somerset"),")."),"\n",l.createElement(t.li,null,"Some tokens such as ",l.createElement(t.code,null,"Flat")," are often omitted for the sake of brevity"),"\n",l.createElement(t.li,null,"Business names are optional and appear at the beginning of an address"),"\n"),"\n",l.createElement(t.p,null,"Tokens in category (1) are relatively easy to identify simply by deriving a list of 'common end tokens' from a large dataset of addresses. Issues (2) and (3) are harder to deal with and I am yet to find a robust methodology."),"\n",l.createElement(t.h3,null,"4. Absence of tokens:  Matching tokens that exist within other candidates, but not the present candidate"),"\n",l.createElement(t.p,null,"Sometimes a token (or n-gram) from the messy address will be present in ",l.createElement(t.em,null,"other")," candidates, but not in the one being scored.  This is a strong indicator ",l.createElement(t.em,null,"against")," the candidate being the true match."),"\n",l.createElement("details",{style:{border:"1px solid #e5e7eb",borderRadius:"6px",padding:"0.5em",margin:"1em 0"}},l.createElement("summary",{style:{fontWeight:"normal",textAlign:"left",margin:"0em"}}," Example - click to expand"),l.createElement(t.p,null,"Consider:"),l.createElement(d.default,{messyAddress:l.createElement(l.Fragment,null,l.createElement(t.mark,null,"Flat")," A, 1 Primrose ",l.createElement(t.mark,null,"Apartments"),", London"),candidates:[{address:l.createElement(l.Fragment,null,"Basement A, Block 1 Primrose ",l.createElement(t.mark,null,"Apartments"),", London"),isMatch:!1},{address:l.createElement(l.Fragment,null,l.createElement(t.mark,null,"Flat A"),", Block 1 Primrose ",l.createElement(t.mark,null,"Apartments"),", London"),isMatch:!0},{address:l.createElement(l.Fragment,null,l.createElement(t.mark,null,"Flat A"),", Block 2 Primrose ",l.createElement(t.mark,null,"Apartments"),", London"),isMatch:!1},{address:l.createElement(l.Fragment,null,l.createElement(t.mark,null,"Flat A"),", 1 Primrose Street, London"),isMatch:!1},{address:l.createElement(l.Fragment,null,l.createElement(t.mark,null,"Flat A"),", 2 Primrose Street, London"),isMatch:!1}]}),l.createElement(t.p,null,"Note that the word ",l.createElement(t.code,null,"flat")," is present in the messy address, and most candidates."),l.createElement(t.p,null,"As a result ",l.createElement(t.code,null,"flat")," is a common token within the candidate set, and does not help discriminate between the ",l.createElement(t.code,null,"flat")," candidates. The score increment due to 'flat' on the basis of token frequencies will be modest, and so will not strongly differentiate the basement candidate from the others."),l.createElement(t.p,null,"However, the absence of ",l.createElement(t.code,null,"flat")," in candidate 1 strongly suggests this cannot be the match, particularly because we know the word ",l.createElement(t.code,null,"flat")," exists in other addresses  (if it existed in no candidates, it would be irrelavant for the purpose of scoring.) To ensure a more highly differentiated score for address 1, we need to apply some sort of score penalty."),l.createElement(t.p,null,"In summary, this enables the differential between (say) address 1 and addresses 2-5 to be greater than the 'reward' 2-5 will gain from matching on the word 'flat'."),l.createElement(t.p,null,"Note that in this example, the token ",l.createElement(t.code,null,"apartments")," also plays a similar role to ",l.createElement(t.code,null,"flat")," in ruling out candidates 4 and 5."),l.createElement(t.p,null,"Also note in this example, there is no bigram or trigram that uniquely identifies the match.")),"\n",l.createElement(t.h3,null,"5. Discriminating tokens amongst neighbouring addresses"),"\n",l.createElement(t.p,null,"In the ",l.createElement(t.code,null,"Rainbow Lane")," example above, we illustrated a technique to find highly discriminating tokens amongst neighbouring addresses."),"\n",l.createElement(t.p,null,"On the face of it, these tokens are essential information to uniquely pin down the address."),"\n",l.createElement(t.p,null,"In practice, addresses are not this simple, and there's no guarantee that:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"the messy address will contain these tokens"),"\n",l.createElement(t.li,null,"the tokens are uniquely discriminating amongst the candidates"),"\n"),"\n",l.createElement(t.p,null,"As a result, instead of requiring a match, we can simply place greater weight on these tokens when scoring."),"\n",l.createElement("details",{style:{border:"1px solid #e5e7eb",borderRadius:"6px",padding:"0.5em",margin:"1em 0"}},l.createElement("summary",{style:{fontWeight:"normal",textAlign:"left",margin:"0em"}}," Example - click to expand"),l.createElement(t.p,null,"The following example illustrates how this simple technique can fail:"),l.createElement(t.p,null,l.createElement(t.strong,null,"Messy address"),":"),l.createElement(t.p,null,l.createElement(t.code,null,"Flat A 10 Station Street")),l.createElement(t.p,null,l.createElement(t.strong,null,"Candidates:")),l.createElement("pre",{style:{display:"inline-block",width:"max-content",textAlign:"right",background:"none",border:"none",padding:0}},l.createElement("pre",null,l.createElement("code",null,"9 Station Street")),l.createElement("pre",null,l.createElement("code",null,l.createElement("mark",null,"Flat A")," 9 Station Street")),l.createElement("pre",null,l.createElement("code",null,"10 Station Street")),l.createElement("pre",null,l.createElement("code",null,l.createElement("mark",null,"Basement Flat")," 10 Station Street")),l.createElement("pre",null,l.createElement("code",null,l.createElement("mark",null,"10A")," Station Street")),l.createElement("pre",null,l.createElement("code",null,l.createElement("mark",null,"10B")," Station Street"))),l.createElement(t.p,null,"Note how the simple rule 'require a match on the discriminating (highlighted) token(s)' would fail in this example; we'd incorrectly match to the ",l.createElement(t.code,null,"9 Station Street")," candidate.")),"\n",l.createElement(t.h3,null,"6. Using a fault tolerant trie"),"\n",l.createElement(t.p,null,"Another powerful approach for matching is a fault tolerant trie, see separate article ",l.createElement(o.rU,{to:"/fault_tolerant_trie/"},"here"),"."),"\n",l.createElement(t.h2,null,"Scoring stage: Interpreting the score"),"\n",l.createElement(t.p,null,"Many record linkage approaches simply treat the score as an ordinal variable, the higher the better.  A score threshold is set, and any candidate above the threshold is considered a match."),"\n",l.createElement(t.p,null,"In the context of address matching, this approach is not very useful because:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"There should be a single match - we do not want to match a single messy address to multiple candidate addresses"),"\n",l.createElement(t.li,null,"There isn't a strong relationship between 'raw' score and the true match status.  For example, the matcher may correctly 'find' the true match for a simple address like ",l.createElement(t.code,null,"1 London Road, Birmingham, B1 1AA"),".  But whilst the top-scoring match may be correct, its score may be relatively low due to the simplicity of the address, and the commonness of the tokens."),"\n"),"\n",l.createElement(t.p,null,"As a result, we need a more nuanced approach to scoring.  The goal is that we want a measure of match confidence."),"\n",l.createElement(t.h3,null,"Using 'distinguishability' to determine match confidence"),"\n",l.createElement(t.p,null,"A powerful technique is to measure the score differential between the top candidate and the second best candidate. We could call this the 'distinguishability' score of the match."),"\n",l.createElement(t.p,null,"The final match confidence score could then be defined as a combination of the raw score and the distinguishability score - often with more weight placed on the distinguishability score, and perhaps a minimum threshold on the raw score.  For instance, we could define an 'almost certain match' as a candidate with high distinguishability and a raw score that is above some medium threshold."),"\n",l.createElement(t.h2,null,"Final thoughts"),"\n",l.createElement(t.p,null,"Many of the techniques described above are initially appealing, and can even seem like 'knock out' solutions.  However, I have found through bitter experience that there is always an edge case that undermines their effectiveness, and often there is tension between the information the different techniques seem to provide."),"\n",l.createElement(t.p,null,"One important reason for this is that the process of candidate search by its nature retrieves a set of candidates that are similar to the messy address - favouring candidates that contain highly discriminative n-grams or other features that 'work against' the scoring rules."),"\n",l.createElement(t.p,null,"I have come to believe that the most powerful address matching solutions are those that:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Apply clever feature engineering tricks to uncover hidden information in the structure of the addresses"),"\n",l.createElement(t.li,null,"Use contextual information from the corpus of all addresses, and the list of candidates, rather than relying only on pairwise information"),"\n",l.createElement(t.li,null,"Combine this information using match weights to decide how important different features are, as opposed to crafting deterministic logic"),"\n",l.createElement(t.li,null,"Learn the match weights from the data itself using e.g. gradient descent."),"\n"),"\n",l.createElement(t.p,null,"I will end with some examples that highlight the challenges of address matching - and are interesting to consider in the context of the techniques described above."),"\n",l.createElement("details",{style:{border:"1px solid #e5e7eb",borderRadius:"6px",padding:"0.5em",margin:"1em 0"}},l.createElement("summary",{style:{fontWeight:"normal",textAlign:"left",margin:"0em"}}," Some examples that highlight the challenges of address matching - click to expand"),l.createElement(c.default,{addressA:l.createElement(l.Fragment,null,"23A Marchant House, Jubilee Street, London, LO1 23D"),addressB:l.createElement(l.Fragment,null,"Flat A, Top Floor, Marchant House, 23 Jubilee Street, Fulham, LO1 23D"),isMatch:!0}),l.createElement(c.default,{addressA:l.createElement(l.Fragment,null,"6, PADDOCK CLOSE CASTLETHORPE MK19 7AY"),addressB:l.createElement(l.Fragment,null,"PIPIT HOUSE, 6, PADDOCK CLOSE, CASTLETHORPE MK19 7AY"),isMatch:!0}),l.createElement(c.default,{addressA:l.createElement(l.Fragment,null,"Maisonette First And Second Floors, 14, Hadyn Park Road"),addressB:l.createElement(l.Fragment,null,"Top Floor Flat 14 Hadyn Park Road, London"),isMatch:!0}),l.createElement(c.default,{addressA:l.createElement(l.Fragment,null,"Flat 39 Evans House White City Estate"),addressB:l.createElement(l.Fragment,null,"39, EVANS HOUSE, AUSTRALIA ROAD, LONDON"),isMatch:!0}),l.createElement(d.default,{messyAddress:l.createElement(l.Fragment,null,"FLAT 3 ST LEGER HOUSE GREAT LINFORD MK14 5HA"),candidates:[{address:l.createElement(l.Fragment,null,"GREAT LINFORD HOUSE 1 ST LEGER COURT GREAT LINFORD MK14 5HA"),isMatch:!1},{address:l.createElement(l.Fragment,null,"3 ST LEGER HOUSE ",l.createElement(t.mark,null,"4A")," ST LEGER COURT GREAT LINFORD MK14 5HA"),isMatch:!0},{address:l.createElement(l.Fragment,null,"3 ST LEGER COURT GREAT LINFORD MK14 5HA"),isMatch:!1}]}),l.createElement(d.default,{messyAddress:l.createElement(l.Fragment,null,"Rear Studio Flat 191a Uxbridge Road W12 9RA"),candidates:[{address:l.createElement(l.Fragment,null,"FLAT GROUND FLOOR REAR, 191A, UXBRIDGE ROAD, LONDON W12 9RA"),isMatch:!0},{address:l.createElement(l.Fragment,null,"NEALE-ROBINSON, 191A, UXBRIDGE ROAD, LONDON W12 9RA "),isMatch:!1},{address:l.createElement(l.Fragment,null,"FIRST FLOOR FLAT, 191A, UXBRIDGE ROAD, LONDON W12 9RA"),isMatch:!1},{address:l.createElement(l.Fragment,null,"REAR OF, 191E, UXBRIDGE ROAD, LONDON, W12 9RA"),isMatch:!1}]})),"\n",l.createElement(t.h2,null,"Acknowledgements"),"\n",l.createElement(t.p,null,"Thanks to ",l.createElement(t.a,{href:"https://github.com/ajl2718"},"Alex Lee")," the author of ",l.createElement(t.code,null,"whereabouts")," for insightful comments and suggestions - all errors remain my own"),"\n",l.createElement(t.section,{"data-footnotes":!0,className:"footnotes"},l.createElement(t.h2,{className:"sr-only",id:"footnote-label"},"Footnotes"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,{id:"user-content-fn-8"},"\n",l.createElement(t.p,null,"A variety of interesting edge cases can be found in ",l.createElement(t.a,{href:"https://www.mjt.me.uk/posts/falsehoods-programmers-believe-about-addresses/"},"Falsehoods Programmers Believe About Addresses"),". ",l.createElement(t.a,{href:"#user-content-fnref-8","data-footnote-backref":!0,className:"data-footnote-backref","aria-label":"Back to content"},"↩")),"\n"),"\n",l.createElement(t.li,{id:"user-content-fn-3"},"\n",l.createElement(t.p,null,"To ensure high performance, I've included only techniques that can be implemented in SQL, meaning we can use high performance engines like DuckDB to implement the address matching system. ",l.createElement(t.a,{href:"#user-content-fnref-3","data-footnote-backref":!0,className:"data-footnote-backref","aria-label":"Back to content"},"↩")),"\n"),"\n",l.createElement(t.li,{id:"user-content-fn-1"},"\n",l.createElement(t.p,null,"A ",l.createElement(t.a,{href:"https://www.ons.gov.uk/methodology/methodologicalpublications/generalmethodology/onsworkingpaperseries/onsworkingpaperseriesno17usingdatasciencefortheaddressmatchingservice"},"Conditional Random Fields")," or ",l.createElement(t.a,{href:"https://pmc.ncbi.nlm.nih.gov/articles/PMC140019/"},"hidden Markov")," model could be used for this, or existing libraries such as ",l.createElement(t.a,{href:"https://github.com/openvenues/libpostal"},"libpostal"),". ",l.createElement(t.a,{href:"#user-content-fnref-1","data-footnote-backref":!0,className:"data-footnote-backref","aria-label":"Back to content"},"↩")),"\n"),"\n",l.createElement(t.li,{id:"user-content-fn-9"},"\n",l.createElement(t.p,null,"The ",l.createElement(t.code,null,"Philpot Square")," address at the top of this article is a good practical example:  how should we interpret the ",l.createElement(t.code,null,"165")," in ",l.createElement(t.code,null,"165, Philpot Square, London"),"?  In difficult examples like this, solving this problem amounts to figuring out what the true address is - so the problem is circular. ",l.createElement(t.a,{href:"#user-content-fnref-9","data-footnote-backref":!0,className:"data-footnote-backref","aria-label":"Back to content"},"↩")),"\n"),"\n",l.createElement(t.li,{id:"user-content-fn-10"},"\n",l.createElement(t.p,null,"High recall is particularly important because some scoring techniques implicitly assume that the true address is among the candidates. ",l.createElement(t.a,{href:"#user-content-fnref-10","data-footnote-backref":!0,className:"data-footnote-backref","aria-label":"Back to content"},"↩")),"\n"),"\n",l.createElement(t.li,{id:"user-content-fn-2"},"\n",l.createElement(t.p,null,"Blocking on postcode only may result in a list of candidates that is too long for performance reasons. In practice, a simple extension could be to limit to addresses that contain the postcode and any of the numbers in the address. ",l.createElement(t.a,{href:"#user-content-fnref-2","data-footnote-backref":!0,className:"data-footnote-backref","aria-label":"Back to content"},"↩")),"\n"),"\n",l.createElement(t.li,{id:"user-content-fn-4"},"\n",l.createElement(t.p,null,"The terminology 'block on' means 'candidate addresses are found using this condition'.   So in this example, we would find any address whose least common bigram  matches the least common bigram in the messy address.  This is conceptually equivalent to an inverted index. ",l.createElement(t.a,{href:"#user-content-fnref-4","data-footnote-backref":!0,className:"data-footnote-backref","aria-label":"Back to content"},"↩")),"\n"),"\n",l.createElement(t.li,{id:"user-content-fn-6"},"\n",l.createElement(t.p,null,"In ",l.createElement(t.code,null,"uk_address_matcher"),", gradient descent has been used to optimise weights, see ",l.createElement(t.a,{href:"https://github.com/RobinL/uk_address_matcher/blob/main/scripts/improve_parameters_using_gradient_descent.py"},"here"),". ",l.createElement(t.a,{href:"#user-content-fnref-6","data-footnote-backref":!0,className:"data-footnote-backref","aria-label":"Back to content"},"↩")),"\n"),"\n",l.createElement(t.li,{id:"user-content-fn-7"},"\n",l.createElement(t.p,null,"In my experience, weighted scoring is better than trying to apply deterministic logic because there are too many edge cases so the 'tree' of if statements quickly becomes unmanageable. ",l.createElement(t.a,{href:"#user-content-fnref-7","data-footnote-backref":!0,className:"data-footnote-backref","aria-label":"Back to content"},"↩")),"\n"),"\n"),"\n"))}t.default=function(e){return void 0===e&&(e={}),l.createElement(r.fE,e,l.createElement(u,e))}},7825:function(e,t,n){n.d(t,{H:function(){return r}});var a=n(7294),l=n(4160);const r=e=>{let{frontmatter:t}=e;const{title:n,description:r,image:s,siteUrl:i,twitterUsername:o}=(0,l.K2)("1865044719").site.siteMetadata,c={title:(null==t?void 0:t.title)||n,description:(null==t?void 0:t.description)||r,image:`${i}${(null==t?void 0:t.image)||s}`,url:`${i}${(null==t?void 0:t.pathname)||""}`,twitterUsername:o,...t},d=null==t?void 0:t.stylesheet;return a.createElement(a.Fragment,null,a.createElement("title",null,c.title),a.createElement("meta",{name:"description",content:c.description}),a.createElement("meta",{name:"image",content:c.image}),d&&a.createElement("link",{rel:"stylesheet",type:"text/css",href:`/styles/${d}`}))}},6760:function(e,t,n){var a=n(7294);t.Z=e=>{let{children:t}=e;const n=a.Children.map(t,(e=>a.isValidElement(e)&&"p"===e.type?e.props.children:e));return a.createElement("h2",{className:"text-xl font-sans font-normal text-gray-500 mb-8 mt-0"},n)}},9373:function(e,t,n){n.r(t),n.d(t,{default:function(){return l}});var a=n(7294);function l(e){let{messyAddress:t,candidates:n=[]}=e;const l={margin:0,padding:"0.25rem",background:"#f3f4f6",borderRadius:"0.25rem",fontFamily:"monospace",fontSize:"0.85rem",whiteSpace:"pre-wrap",lineHeight:1.3},r={fontWeight:600,fontSize:"0.75rem",color:"#374151",letterSpacing:"0.01em"},s=1===n.length?"Candidate address":"Candidate addresses";return a.createElement("div",{style:{border:"1px solid #d1d5db",borderRadius:"0.25rem",padding:"0.75rem",maxWidth:"40rem",display:"flex",flexDirection:"column",gap:"0.75rem",fontSize:"0.85rem",marginBottom:"0.5em"}},a.createElement("div",null,a.createElement("span",{style:r},"Messy address"),a.createElement("pre",{style:{...l,marginTop:"0.25rem"}},t)),a.createElement("div",null,a.createElement("span",{style:r},s),a.createElement("div",{style:{display:"flex",flexDirection:"column",gap:"0.4rem",marginTop:"0.25rem"}},n.map(((e,t)=>{let{address:n,isMatch:r}=e;const s="#16a34a",i="#7f1d1d";let o,c,d="1px solid transparent",m="";return!0===r?(d=`1px solid ${s}`,m="✅",c=s):!1===r&&(o=i,m="",c=i),a.createElement("div",{key:t,style:{display:"flex",flexDirection:"row",alignItems:"stretch"}},a.createElement("span",{style:{fontFamily:"inherit",fontWeight:500,fontSize:"0.85rem",color:"#6b7280",minWidth:"1.5rem",textAlign:"right",marginRight:"0.0rem",userSelect:"none",display:"flex",alignItems:"flex-start",paddingTop:"0.25rem"}},t+1,"."),a.createElement("div",{style:{display:"flex",flex:1,alignItems:"center",gap:"0.6rem",border:d,borderRadius:"0.25rem",padding:"0.25rem"}},a.createElement("pre",{style:{...l,margin:0,color:o}},n),a.createElement("span",{style:{fontSize:"1.1rem",lineHeight:1,color:c,userSelect:"none",width:"1.25rem",textAlign:"center"}},m)))})))))}},40:function(e,t,n){n.r(t),n.d(t,{default:function(){return l}});var a=n(7294);function l(e){let{addressA:t,addressB:n,isMatch:l}=e;const r=l?"#16a34a":"#dc2626",s=l?"match":"non-match",i=l?"✅":"❌",o={margin:0,padding:"0.25rem",background:"#f3f4f6",borderRadius:"0.25rem",fontFamily:"monospace",fontSize:"0.85rem",whiteSpace:"pre-wrap",lineHeight:1.3};return a.createElement("div",{style:{border:`1px solid ${r}`,borderRadius:"0.25rem",padding:"0.5rem",display:"flex",alignItems:"center",gap:"0.75rem",maxWidth:"40rem"}},a.createElement("div",{style:{flex:1}},a.createElement("pre",{style:o},t),a.createElement("pre",{style:{...o,marginTop:"0.35rem"}},n)),a.createElement("div",{style:{display:"flex",flexDirection:"column",alignItems:"center",color:r,fontWeight:700,fontSize:"0.8rem",userSelect:"none",minWidth:"4.5rem"}},a.createElement("span",{style:{fontSize:"1.4rem",lineHeight:1}},i),s))}}}]);
//# sourceMappingURL=component---src-mdx-address-matching-mdx-ab4e0cfbac2c26fa3c43.js.map